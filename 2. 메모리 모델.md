# 2. 메모리 모델

계약 - 프로그래머와 시스템 사이에 체결된 계약으로 계약이 꼼꼼할수록 최적의 실행 파일을 만들 수 있는 시스템의 유연성이 줄어듬

## C++11의 계약 수준

1. 싱글 스레딩 - 하나의 제어 흐름 - 가장 꼼꼼함
2. 멀티 스레딩 - 태스크, 스레드, 조건 변수 - 중간
3. 원자계 - 시퀀스 일관성, 시맨틱, 편안한 시맨틱

- C++11이전에는 계약이 하나 뿐이었음(멀티스레딩과 원자계 미포함)
- 따라서 시스템은 하나의 제어 흐름만 알았고, 그로 인해 최적의 실행 파일을 만들 수 있는 방법이 제한적이었음

### C++의 메모리 모델에서 다루는 핵심

- 원자계 연산 - 방해 받지 않고 수행될 수 있는 연산
- 연산의 부분적 순서 지정 - 재지정될 수 없는 일련의 연산 순서
- 연산의 시각 효과 - 공유 변수에 수행되는 연산을 다른 스레드에서 언제 볼 수 있다는 보장

### 메모리 모델이 허술해질수록 다뤄야 하는 것

- 더 높아진 시스템 최적화 가능성
- 기하급수적으로 늘어나는 프로그램의 제어 흐름 횟수
- 전문가 영역
- 제어 흐름과 어긋나는 직관
- 미세최적화



## 원자계

### 꼼꼼한 메모리 모델(시퀀스 일관성) vs 허술한 메모리 모델(편안한 시맨틱)

#### 꼼꼼한 메모리 모델

시퀀스 일관성은 다음 두 가지를 보장함(원자계에만 해당)

- 프로그램의 명령들은 소스 코드의 순서대로 실행됨
- 스레드 연산 전체를 아우르는 순서가 있음

각각 변수 x와 y를 저장하고, 상대편 변수 y와 x를 로드한 뒤 이를 각각 res1과 res2에 저장하는 두 스레드가 있을 경우

1. 시퀀스 일관성의 첫 번째 보장에 따라 저장 연산이 로드 연산보다 먼저일 수 없다

2. 시퀀스 일관성의 두 번째 보장에 따라 스레드의 명령은 하나의 예외도 없이 전체 순서를 따라야 한다. 

   global order - 스레드는 다른 스레드가 연산을 실행하는 소스코드의 순서대로 다른 스레드의 연산을 이해함.

3. global order에 맞춰 한 번에 하나의 원자계 연산이 실행되지만, 정확히 어느 연산이 실행되는지는 알 수 없음

#### 허술한 메모리 모델

- 시스템은 data race가 없는 한 well-defined 프로그램 동작을 보장함
- global order의 개념이 존재하지 않아 스레드가 다른 스레드를 보면 연산의 순서가 뒤죽박죽이 될 수 있음
- 교차 실행을 이해하기 어려워지며 최적화 선택지가 훨씬 많아짐
- acquire-release 시맨틱 모델 - 시퀀스 일관성보다도 더 허술한 규칙을 따라야 하며 멀티 스레딩 프로그래밍에서 동기화 및 부분적 순서 지정을 더욱 깊이 있게 이해하기 위한 열쇠->스레드들이 소스 코드 내 특정 동기화 지점에서 동기화되기 때문
- 원자계 연산은 제각각 메모리 순서를 지정할 수 있음. 지정하지 않으면 시퀀스 일관성이 기본으로 적용됨.

### 원자계 플래그(atomic_flag)

std::atomic_flag의 인터페이스 - clear 메소드는 플래그 값을 false로 설정하고, test_and_set 메소드는 이를 true로 되돌림

atomic_flag의 특성

- 잠김 없는 유일한 원자계임. 논블로킹 알고리즘은 시스템 차원에서 수행된다는 보장이 없으면 잠김 없음임.
- 더 높은 수준의 스레드 추상화를 위한 빌딩 블록

원자계에는 C++표준에 따라 내부적으로 뮤텍스를 사용하는 강력한 기능이 있음 -> 자신이 내부적으로 뮤텍스를 사용하는지 확인하기 위해 _lock_free메소드 제공

스핀락 - 뮤텍스처럼 임계구역을 보호할 수 있으나, 뮤텍스와 달리 잠김을 받을 때까지 수동적으로 기다리지 않고 임계 구역에 접근하기 위해 잠김을 적극적으로 요청. 사용자 공간에서 커널 공간까지 옮겨 가는 대기 상태 동안 과도한 switch loop를 줄이지만 CPU를 최대한 활용하여 CPU사이클을 낭비함