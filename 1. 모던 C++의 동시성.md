# 1. 모던 C++의 동시성

## 메모리 모델

메모리 모델이 잘 정의되려면 다음 세 가지를 처리할 수 있어야 함

- 원자계 연산 - 방해받지 않고 수행될 수 있는 연산(Atomic)
- 연산의 부분 순서 - 순서가 재지정되어야 하는 일련의 연산
- 연산의 시각 효과 - 공유 변수의 연산이 다른 스레드에 보인다는 보장

C++의 메모리 모델은 자바의 메모리 모델에서 영감을 받아 만들었지만 C++은 원자계 연산의 기본 특성인 시퀀스 일관성의 한계를 허물었음

**시퀀스 일관성**

- 프로그램의 명령들은 소스 코드의 순서대로 실행됨
- 어떤 스레드에든 수행되는 연산 모두에 하나의 순서가 적용됨



## 멀티스레딩

C++ 멀티스레딩의 구성 요소

- 스레드
- 공유 데이터를 위한 동기화 프리미티브
- 스레드 로컨 데이터
- 태스크

### 스레드

- std::thread는 프로그램 실행의 독립적인 단위를 나타냄. 
- 곧바로 시작되는 실행 가능 유닛은 작업 패키지를 callable unit으로 받음.
- 스레드의 생성자는 스레드의 라이프사이클도 책임짐->새 스레드의 실행 가능 유닛은 Callable unit의 종료와 함께 종료됨
- 이후 생성된 스레드가 종료될때까지 생성자가 기다리거나(join) 생성된 스레드에서 생성자 자체가 분리됨(detach)
- 스레드 t는 자신에게 join이나 detach 연산이 수행되지 않으면 joinable이며, joinable스레드는 소멸자로 std::terminate를 호출하여 프로그램을 종료함
- 데몬 스레드 - 자신의 생성자로부터 분리된 스레드(백그라운드에서 실행되기 때문)

### 공유 데이터

둘 이상의 스레드가 동시에 공유 변수를 사용하거나 공유 변수를 변형할 수 있다면 이 변수에 대한 접근을 조정해야 함(data race). -> 운영체제 컨텍스트 스위칭 부분 참고

### 뮤텍스

언제든 단 하나의 스레드만 공유 변수에 접근할 수 있음을 보장함.

공유 변수가 속한 임계 구역을 잠그거나 잠김의 해제를 수행함. -> 운영체제 스레드 부분 참고

C++은 다섯 개의 뮤텍스를 지원하며 재귀적으로, 잠정적으로, 시간 제약 조건의 유무에 따라 잠김을 수행할 수 있으며 잠김을 공유할 수도 있음

#### 잠김

- 뮤텍스의 잠김을 자동으로 해제하기 위해 잠김으로 뮤텍스를 캡슐화할 수 있음
- 잠김은 뮤텍스의 라이프사이클을 자신에게 바인딩함으로써 RAII 이디엄(idiom)을 구현함
- C++은 단순 목적으로 std::lock_guard와 고급 목적으로 std::unique_lock/std::shared_lock을 제공함

#### 데이터의 스레드 안전한 초기화

- 공유 데이터가 읽기 전용이면 thread-safe한 방식으로 초기화할 수 있음
- C++은 상수식, 블록 영역의 정적 변수, std::once_flag 플래그가 적용된 std::call_once 함수 등을 비롯해 각종 방법을 제공함

#### 스레드 로컬 데이터

- 변수를 thread-local로 선언하면 각 스레드가 자신의 복사본을 받게 됨->공유 변수 필요 x
- 스레드 로컬 데이터의 라이프사이클은 스레드의 라이프사이클에 바인딩됨

#### 조건 변수

- 메시지를 통한 스레드 동기화를 지원
- 한 스레드가 발신자의 역할, 다른 스레드가 수신자의 역할을 맡음->수신자 블록은 발신자의 메시지를 기다림
- 조건 변수는 흔히 생산자/소비자 작업 흐름에 사용됨
- 사용이 어려워 태스크가 쉬운 해결책으로 등장함

#### 태스크

- 스레드는 명시적으로 만들어야 하는 반면, 태스크는 시작한 작업을 단순하게 일컫는 말
- C++런타임은 std::async에 따라 자동으로 태스크의 라이프사이클을 처리함
- 태스크는 두 교신점 사이의 데이터 채널로 스레드 간 안전한 교신을 지원함
- 한쪽 지점으로서 promise가 데이터를 데이터 채널에 두면 다른 쪽 지점으로서 future가 그 값을 가져감->비동기
- C++은 태스크를 더 세부적으로 제어하는 클래스 템플릿인 std::promise와 std::future를 제공함

### 원자계 스마트 포인터

- std::shared_ptr과 std::weak_ptr은 본질적으로 변형할 수 있는 데이터를 공유함. 따라서 data racing에 취약하며 그 결과 정의하지 않은 동작이 일어남.
- std::shared_ptr과 std::weak_ptr은 레퍼런스 카운터의 증감이 원자계 연산이고, 리소스는 정확하게 한 번만 삭제된다고 보장함.
- 그러나, 이 둘 중 어느 것도 리소스에 대한 접근이 원자계임을 보장하지 않음. -> std::atomic_shared_ptr과 std::atomic_weak_ptr이 이를 해결함

### 확장 퓨처

C++11의 프로미스와 퓨처로 불리는 태스크는 강력한 workflow로 구성될 수 없음. -> C++20의 확장 퓨처(extended future)로 해결 가능

### 래치와 장벽

C++14는 세마포어를 제공하지 않음. C++20에서 latch와 barrier를 제안하고 있다.

latch와 barrier는 카운터가 0이 될 때까지 동기화 지점에서 기다리는 데 사용됨. latch와 barrier는 std::latch가 한 번만 사용되고 std::barrier and std::flex_barrier가 그 이상 사용된다는 점에서 사용됨

std::flex_barrier는 std::barrier와 달리 반복 후에도 카운터를 조정할 수 있음

### 코루틴

함수 자신의 상태를 유지하면서 실행을 중지 및 재개할 수 있는 함수.

코루틴은 운영체제의 협조적 멀티태스킹과 이벤트 루프, 무한 리스트, 파이프라인 등을 구현할 수 있는 접근 방식

### 트랜잭션 메모리

트랜잭션 - ACID 데이터베이스 트랜잭션의 처음 세 특성인 **원자성, 일관성, 분리성**을 제공하는 액션

트랜잭션 메모리에는 동기화 블록과 원자계 블록이 적용되었음.

둘 다 전체 순서에 따라 실행되며, 전체 잠김에 보호받는 것처럼 동작함.

원자계 블록은 동기화 블록과 달리 transaction-unsafe 코드를 실행할 수 없음

### 태스크 블록

C++의 fork-join패러다임을 구현함. 태스크를 시작하는 fork단계와 동기화하는 join단계로 구성됨.